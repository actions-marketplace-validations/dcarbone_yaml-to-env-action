name: YAML to ENV
description: |
  Parse all keys & values out of a YAML file, adding them to the $GITHUB_ENV file

branding:
  icon: copy
  color: blue

inputs:
  yaml-file:
    required: true
    description: "Filepath to YAML to parse"
  yq-version:
    required: false
    default: "4.27.5"
    description: "Version of yq to install, if not already in path.  Tested with >= 4.25."
  debug:
    required: false
    default: "false"
    description: "Enable debug logging.  This WILL print un-masked secrets to stdout, so use with caution."

outputs:
  yq-installed:
    description: "'true' if yq was installed by this action"
    value: "${{ steps.yq-check.outputs.found == 'false' }}"

runs:
  using: composite
  steps:
    - name: Check yaml file existence
      shell: bash
      run: |
        if ! [ -f '${{ inputs.yaml-file }}' ]; then
          echo 'Configured YAML file "${{ inputs.yaml-file }}" not found'
          exit 1
        fi

    - name: Check for yq
      id: yq-check
      shell: bash +e {0}
      run: |
        _yq_bin="$(which yq)"
        if [ -f "${_yq_bin}" ]; then
          echo "::set-output name=found::true"
        else
          echo "::set-output name=found::false"
        fi

    - name: 'Install yq (${{ inputs.yq-version }})'
      uses: chrisdickinson/setup-yq@latest
      if: steps.yq-check.outputs.found == 'false'
      with:
        yq-version: '${{ inputs.yq-version }}'

    - name: YAML to ENV
      shell: bash
      run: |
        function _debug_log () { if [[ '${{ inputs.debug }}' == 'true' ]]; then printf '[DEBUG] - %s' "${@}"; echo ""; fi; }
        function _join_by { local IFS="$1"; shift; echo "$*"; }
        function _trim() { printf '%s' "${1}" | sed 's/^[[:blank:]]*//; s/[[:blank:]]*$//'; }
        function _ltrim_one { printf '%s' "${1}" | sed 's/^[[:blank:]]//'; }
        function _rtrim_one { printf '%s' "${1}" | sed 's/[[:blank:]]$//'; }
        function _upper() { printf '%s' "${1}" | tr '[:lower:]' '[:upper:]'; }
        function _env_name() {  _upper "${1}" | tr '.' '_'; }
        
        _write_env_file_line() {
          _debug_log "${1} >> $GITHUB_ENV"
          printf '%s' "${1}" | sed -e 's/\\n/\n/g' >> $GITHUB_ENV
          printf '\n' >> $GITHUB_ENV
        }
        
        _write_kv_to_env_file() {
          local _n
          local _v
          local _re
          _n="$(_env_name "${1}")"
          _v="${2}"
          _re='\\n'
          if [[ "${_v}" =~ $_re ]]; then
            _write_env_file_line "${_n}<<EOF"
            _write_env_file_line "${_v}"
            _write_env_file_line 'EOF'
          else
            _write_env_file_line "${_n}=${_v}"
          fi
        }
        
        _parse_yq_output() {
          local _lines
          local _line
          local _split
          local _key
          local _value
          local _clean_value
        
          _lines=()
          readarray -t _lines <<< "${1}"
        
          _debug_log "${#_lines[@]} possible value(s) and / or comments seen in file"
        
          for _line in "${_lines[@]}"; do
            _debug_log "_line='${_line}'"
        
            if [ -z "${_line}" ]; then
              _debug_log "Skipping empty line"
              continue
            fi
        
            if [[ "${_line}" =~ ^# ]]; then
              _debug_log "Skipping comment line \"${_line}\""
              continue
            fi
        
            _split=()
            IFS=$'='; read -r -a _split <<< "${_line}"
        
            for (( i=0; i < "${#_split[@]}"; i++ )); do
              _debug_log "_split.${i}='${_split[$i]}'"
            done
        
            _key="$(_rtrim_one "${_split[0]}")"
            _value="$(_join_by '=' "${_split[@]:1}")"
            _clean_value="$(_ltrim_one "${_value}")"
        
            _debug_log "_key='${_key}'"
            _debug_log "_value='${_value}'"
            _debug_log "_clean_value='${_clean_value}'"
        
            _write_kv_to_env_file "${_key}" "${_clean_value}"
        
          done
        }
        
        _debug_log "Writing to \"$GITHUB_ENV\":"
        _all_fields="$(yq -o p '.' '${{ inputs.yaml-file }}')"
        _parse_yq_output "${_all_fields}"
